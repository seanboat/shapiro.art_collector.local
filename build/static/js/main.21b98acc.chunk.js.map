{"version":3,"sources":["components/Title.js","api/index.js","components/Search.js","components/Preview.js","components/Feature.js","components/Loading.js","index.js"],"names":["Title","id","BASE_URL","KEY","fetchQueryResultsFromTermAndValue","term","value","a","fetch","encodeURI","split","join","response","json","data","fetchQueryResultsFromURL","url","fetchQueryResults","century","classification","queryString","fetchAllCenturies","localStorage","getItem","JSON","parse","records","setItem","stringify","fetchAllClassifications","Search","props","useState","centuryList","setCenturyList","classificationList","setClassificationList","setQueryString","setCentury","setClassification","setIsLoading","setSearchResults","useEffect","centuries","classifications","console","error","getCenturiesAndClassifications","onSubmit","event","preventDefault","results","htmlFor","type","placeholder","onChange","target","className","length","name","map","option","index","key","Preview","searchResults","setFeaturedResult","info","fetchPage","pageUrl","disabled","prev","onClick","next","record","primaryimageurl","src","alt","description","title","Searchable","searchTerm","searchValue","href","result","Feature","featuredResult","dated","culture","technique","medium","images","image","idsid","baseimageurl","alttext","Loading","App","isLoading","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.21b98acc.chunk.js","sourcesContent":["import React from \"react\";\n\n//  Create/export a component called Title which uses this static HTML as the template:\n\nexport default function Title() {\n  return (\n    <div id=\"title\">\n      <h1>The Art Collector</h1>\n      <h5>Search the Harvard Art Museums' Private Collections</h5>\n    </div>\n  );\n}\n","/**\n * This file features and exports all of your calls to the API\n *\n * You need to replace YOUR_API_KEY in the string associated with KEY with your actual API key\n */\nexport const BASE_URL = \"https://api.harvardartmuseums.org\";\nexport const KEY = \"apikey=93cdf27d-723a-4865-af47-0a02fa9c7484\";\n\n/**\n * This will make a call to the API for a single term and value (e.g. \"person\", and \"unknown\"), and return the result\n */\nexport async function fetchQueryResultsFromTermAndValue(term, value) {\n  try {\n    const response = await fetch(\n      `${BASE_URL}/object?${KEY}&${term}=${encodeURI(\n        value.split(\"-\").join(\"|\")\n      )}`\n    );\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This will make a call to the API for a preformed url (useful for previous and next buttons), and return the result\n */\nexport async function fetchQueryResultsFromURL(url) {\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * Requires an object { century: '', classification: '', queryString: '' } to be passed in as an argument\n *\n * Then makes a call to the API, and returns the first page of results\n */\nexport async function fetchQueryResults({\n  century,\n  classification,\n  queryString,\n}) {\n  const url = `${BASE_URL}/object?${KEY}&classification=${classification}&century=${century}&keyword=${queryString}`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This returns early if there are centuries stored in localStorage, or fetches them from the API and stores them in localStorage if not\n */\nexport async function fetchAllCenturies() {\n  if (localStorage.getItem(\"centuries\")) {\n    return JSON.parse(localStorage.getItem(\"centuries\"));\n  }\n\n  const url = `${BASE_URL}/century?${KEY}&size=100&sort=temporalorder`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    const records = data.records;\n\n    localStorage.setItem(\"centuries\", JSON.stringify(records));\n\n    return records;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This returns early if there are classifications stored in localStorage, or fetches them from the API and stores them in localStorage if not\n */\nexport async function fetchAllClassifications() {\n  if (localStorage.getItem(\"classifications\")) {\n    return JSON.parse(localStorage.getItem(\"classifications\"));\n  }\n\n  const url = `${BASE_URL}/classification?${KEY}&size=100&sort=name`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    const records = data.records;\n\n    localStorage.setItem(\"classifications\", JSON.stringify(records));\n\n    return records;\n  } catch (error) {\n    throw error;\n  }\n}\n","import React, { useEffect, useState } from \"react\";\n\n/**\n * Don't touch these imports!\n */\nimport {\n  fetchAllCenturies,\n  fetchAllClassifications,\n  fetchQueryResults,\n} from \"../api\";\n\nconst Search = (props) => {\n  const [centuryList, setCenturyList] = useState([]);\n  const [classificationList, setClassificationList] = useState([]);\n  const [queryString, setQueryString] = useState(\"\");\n  const [century, setCentury] = useState(\"any\");\n  const [classification, setClassification] = useState(\"any\");\n\n  const { setIsLoading, setSearchResults } = props;\n\n  // Make sure to destructure setIsLoading and setSearchResults from the props\n\n  /**\n   * We are at the Search component, a child of app. This has a form, so we need to use useState for\n   * our controlled inputs:\n   *\n   * centuryList, setCenturyList (default should be an empty array, [])\n   * classificationList, setClassificationList (default should be an empty array, [])\n   * queryString, setQueryString (default should be an empty string, '')\n   * century, setCentury (default should be the string 'any')\n   * classification, setClassification (default should be the string 'any')\n   */\n\n  /**\n   * Inside of useEffect, use Promise.all([]) with fetchAllCenturies and fetchAllClassifications\n   *\n   * In the .then() callback pass the returned lists to setCenturyList and setClassificationList\n   *\n   * Make sure to console.error on caught errors from the API methods.\n   */\n  useEffect(() => {\n    async function getCenturiesAndClassifications() {\n      try {\n        const centuries = await fetchAllCenturies();\n        const classifications = await fetchAllClassifications();\n        setCenturyList(centuries);\n        setClassificationList(classifications);\n      } catch (ex) {\n        console.error(ex);\n      }\n    }\n    getCenturiesAndClassifications();\n  }, []);\n\n  /**\n   * This is a form element, so we need to bind an onSubmit handler to it which:\n   *\n   * calls event.preventDefault()\n   * calls setIsLoading, set it to true\n   *\n   * then, in a try/catch/finally block:\n   *\n   * try to:\n   * - get the results from fetchQueryResults({ century, classification, queryString })\n   * - pass them to setSearchResults\n   *\n   * catch: error to console.error\n   *\n   * finally: call setIsLoading, set it to false\n   */\n  return (\n    <form\n      id=\"search\"\n      onSubmit={async (event) => {\n        event.preventDefault();\n        setIsLoading(true);\n        try {\n          const results = await fetchQueryResults({\n            century,\n            classification,\n            queryString,\n          });\n          setSearchResults(results);\n        } catch (ex) {\n          console.error(ex);\n        } finally {\n          setIsLoading(false);\n        }\n\n        // write code here\n      }}\n    >\n      <fieldset>\n        <label htmlFor=\"keywords\">Query</label>\n        <input\n          id=\"keywords\"\n          type=\"text\"\n          placeholder=\"enter keywords...\"\n          value={queryString /* this should be the query string */}\n          onChange={\n            (event) => {\n              setQueryString(event.target.value);\n            } /* this should update the value of the query string */\n          }\n        />\n      </fieldset>\n      <fieldset>\n        <label htmlFor=\"select-classification\">\n          Classification{\" \"}\n          <span className=\"classification-count\">\n            ({classificationList.length})\n          </span>\n        </label>\n        <select\n          name=\"classification\"\n          id=\"select-classification\"\n          value={classification /* this should be the classification */}\n          onChange={\n            (event) => {\n              setClassification(event.target.value);\n            } /* this should update the value of the classification */\n          }\n        >\n          <option value=\"any\">Any</option>\n          {/* map over the classificationList, return an <option /> */}\n          {classificationList.map((option, index) => (\n            <option key={index}>{option.name}</option>\n          ))}\n        </select>\n      </fieldset>\n      <fieldset>\n        <label htmlFor=\"select-century\">\n          Century <span className=\"century-count\">({centuryList.length})</span>\n        </label>\n        <select\n          name=\"century\"\n          id=\"select-century\"\n          value={century /* this should be the century */}\n          onChange={\n            (event) => {\n              setCentury(event.target.value);\n            } /* this should update the value of the century */\n          }\n        >\n          <option value=\"any\">Any</option>\n          {/* map over the centuryList, return an <option /> */}\n          {centuryList.map((option, index) => (\n            <option key={index}>{option.name}</option>\n          ))}\n        </select>\n      </fieldset>\n      <button>SEARCH</button>\n    </form>\n  );\n};\n\nexport default Search;\n","import React from \"react\";\n\n/**\n * We need to import fetchQueryResultsFromURL since we will sometimes have urls in info.prev and info.next\n * which are query urls.\n */\nimport { fetchQueryResultsFromURL } from \"../api\";\n\nconst Preview = (props) => {\n  const { setSearchResults, searchResults, setIsLoading, setFeaturedResult } =\n    props;\n  const { info, records } = searchResults;\n\n  /**\n   * Destructure setSearchResults, setFeaturedResult, and setIsLoading from props\n   * and also destructure info and records from props.searchResults\n   *\n   * You need info, records, setSearchResults, setFeaturedResult, and setIsLoading as available constants\n   */\n\n  /**\n   * Don't touch this function, it's good to go.\n   *\n   * It has to be defined inside the Preview component to have access to setIsLoading, setSearchResults, etc...\n   */\n  async function fetchPage(pageUrl) {\n    setIsLoading(true);\n\n    try {\n      const results = await fetchQueryResultsFromURL(pageUrl);\n      setSearchResults(results);\n    } catch (error) {\n      console.error(error);\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  return (\n    <aside id=\"preview\">\n      <header className=\"pagination\">\n        {/* This button should be disabled if nothing is set in info.prev, and should call fetchPage with info.prev when clicked */}\n        <button\n          disabled={!info?.prev}\n          className=\"previous\"\n          onClick={() => {\n            fetchPage(info.prev);\n          }}\n        >\n          Previous\n        </button>\n        {/* This button should be disabled if nothing is set in info.next, and should call fetchPage with info.next when clicked */}\n        <button\n          disabled={!info?.next}\n          className=\"next\"\n          onClick={() => {\n            fetchPage(info.next);\n          }}\n        >\n          Next\n        </button>\n      </header>\n      <section className=\"results\">\n        {records &&\n          records.map((record, index) => (\n            <div\n              key={index}\n              className=\"object-preview\"\n              onClick={(event) => {\n                event.preventDefault();\n                // prevent the default\n                setFeaturedResult(record);\n\n                // set the featured result to be this record, using setFeaturedResult\n              }}\n            >\n              {\n                record.primaryimageurl && (\n                  <img src={record.primaryimageurl} alt={record.description} />\n                )\n\n                // if the record.primaryimageurl exists, show this: <img src={ record.primaryimageurl } alt={ record.description } />, otherwise show nothing\n              }\n              <h3>{record.title || \"MISSING INFO\"}</h3>\n            </div>\n          ))}\n        {/* Here we should map over the records, and render something like this for each one:\n          \n          <div  \n            key={ index }\n            className=\"object-preview\"\n            onClick={(event) => {\n              // prevent the default\n              // set the featured result to be this record, using setFeaturedResult\n            }}>\n            { \n              // if the record.primaryimageurl exists, show this: <img src={ record.primaryimageurl } alt={ record.description } />, otherwise show nothing \n            }\n            {\n              // if the record.title exists, add this: <h3>{ record.title }</h3>, otherwise show this: <h3>MISSING INFO</h3>\n            }\n          </div>\n        */}\n      </section>\n    </aside>\n  );\n};\n\nexport default Preview;\n","import React, { Fragment } from \"react\";\n\n// Don't touch this import\nimport {\n  fetchQueryResultsFromTermAndValue,\n  BASE_URL,\n  fetchQueryResultsFromURL,\n} from \"../api\";\n\n/**\n * We need a new component called Searchable which:\n *\n * Has a template like this:\n *\n * <span className=\"content\">\n *  <a href=\"#\" onClick={async (event) => {}}>SOME SEARCH TERM</a>\n * </span>\n *\n * You'll need to read searchTerm, searchValue, setIsLoading, and setSearchResults off of the props.\n *\n * When someone clicks the anchor tag, you should:\n *\n * - preventDefault on the event\n * - call setIsLoading, set it to true\n *\n * Then start a try/catch/finally block:\n *\n * try:\n *  - await the result of fetchQueryResultsFromTermAndValue, passing in searchTerm and searchValue\n *  - send the result to setSearchResults (which will update the Preview component)\n * catch:\n *  - console.error the error\n * finally:\n *  - call setIsLoading, set it to false\n */\nconst Searchable = (props) => {\n  const { searchTerm, searchValue, setIsLoading, setSearchResults } = props;\n  return (\n    <span className=\"content\">\n      <a\n        href=\"#\"\n        onClick={async (event) => {\n          event.preventDefault();\n          setIsLoading(true);\n          try {\n            const result = await fetchQueryResultsFromTermAndValue(\n              searchTerm,\n              searchValue\n            );\n            setSearchResults(result);\n          } catch (ex) {\n            console.error(ex);\n          } finally {\n            setIsLoading(false);\n          }\n        }}\n      >\n        {searchValue}\n      </a>\n    </span>\n  );\n};\n/**\n * We need a new component called Feature which looks like this when no featuredResult is passed in as a prop:\n *\n * <main id=\"feature\"></main>\n *\n * And like this when one is:\n *\n * <main id=\"feature\">\n *   <div className=\"object-feature\">\n *     <header>\n *       <h3>OBJECT TITLE</h3>\n *       <h4>WHEN IT IS DATED</h4>\n *     </header>\n *     <section className=\"facts\">\n *       <span className=\"title\">FACT NAME</span>\n *       <span className=\"content\">FACT VALUE</span>\n *       <span className=\"title\">NEXT FACT NAME</span>\n *       <span className=\"content\">NEXT FACT VALUE</span>\n *     </section>\n *     <section className=\"photos\">\n *       <img src=IMAGE_URL alt=SOMETHING_WORTHWHILE />\n *     </section>\n *   </div>\n * </main>\n *\n * The different facts look like this: title, dated, images, primaryimageurl, description, culture, style,\n * technique, medium, dimensions, people, department, division, contact, creditline\n *\n * The <Searchable /> ones are: culture, technique, medium (first toLowerCase it), and person.displayname (one for each PEOPLE)\n *\n * NOTE: people and images are likely to be arrays, and will need to be mapped over if they exist\n *\n * This component should be exported as default.\n */\n\nconst Feature = (props) => {\n  const { featuredResult, setIsLoading, setSearchResults } = props;\n  const { title, dated, culture, technique, medium, images } =\n    featuredResult || {};\n\n  return (\n    <main id=\"feature\">\n      {featuredResult && (\n        <div className=\"object-feature\">\n          <header>\n            <h3>{title}</h3>\n            <h4>{dated}</h4>\n          </header>\n          <section className=\"facts\">\n            <span className=\"title\">Culture</span>\n            <span className=\"content\">\n              <Searchable\n                searchTerm={\"culture\"}\n                searchValue={culture}\n                setIsLoading={setIsLoading}\n                setSearchResults={setSearchResults}\n              />\n            </span>\n            {technique && (\n              <>\n                <span className=\"title\">Technique</span>\n                <span className=\"content\">\n                  <Searchable\n                    searchTerm={\"technique\"}\n                    searchValue={technique}\n                    setIsLoading={setIsLoading}\n                    setSearchResults={setSearchResults}\n                  />\n                </span>\n              </>\n            )}\n            {medium && (\n              <>\n                <span className=\"title\">Medium</span>\n                <span className=\"content\">\n                  <Searchable\n                    searchTerm={\"medium\"}\n                    searchValue={medium}\n                    setIsLoading={setIsLoading}\n                    setSearchResults={setSearchResults}\n                  />\n                </span>\n              </>\n            )}\n          </section>\n          <section className=\"photos\">\n            {images.map((image) => (\n              <img\n                key={image.idsid}\n                src={image.baseimageurl}\n                alt={image.alttext}\n              />\n            ))}\n          </section>\n        </div>\n      )}\n    </main>\n  );\n};\n\nexport default Feature;\n","import React from \"react\";\n\n// Create and export a component called Loading which uses this static HTML template:\n\nexport default function Loading() {\n  return (\n    <div id=\"loading\">\n      <h2 className=\"message\">Searching...</h2>\n    </div>\n  );\n}\n","import React, { useState } from \"react\";\nimport ReactDOM from \"react-dom\";\n\n// These imports won't work until you fix ./components/index.js\nimport { Feature, Loading, Preview, Search, Title } from \"./components\";\n\nconst App = () => {\n  const [searchResults, setSearchResults] = useState({ info: {}, records: [] });\n  const [featuredResult, setFeaturedResult] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n\n  /**\n   * We are at the App level component, which is top-most. Any state which needs to be shared between immediate children should\n   * be made here, so create state pairs using useState() for:\n   *\n   * searchResults, setSearchResults (default should be this object:  {info: {}, records: []} )\n   * featuredResult, setFeaturedResult (default should be null)\n   * isLoading, setIsLoading (default should be false)\n   */\n\n  return (\n    <div className=\"app\">\n      {/* <Title /> is static, doesn't need any props */}\n      <Title />\n      {/* <Search /> needs props for setIsLoading and setSearchResults (trigger <Loading /> on search start/end, and transfer results to preview) */}\n      <Search setIsLoading={setIsLoading} setSearchResults={setSearchResults} />\n      {/* <Preview /> needs props for searchResults, setIsLoading and setSearchResults (clicking prev/next buttons), and setFeaturedResult (clicking a preview) */}\n      <Preview\n        searchResults={searchResults}\n        setFeaturedResult={setFeaturedResult}\n        setSearchResults={setSearchResults}\n        setIsLoading={setIsLoading}\n      />\n      {/* <Feature /> needs props for featuredResult, as well as setIsLoading and setSearchResults (clicking on searchable properties) */}\n      <Feature\n        featuredResult={featuredResult}\n        setIsLoading={setIsLoading}\n        setSearchResults={setSearchResults}\n      />\n      {/* <Loading /> is static, but should only render when isLoading is true */}\n      {\n        isLoading && (\n          <Loading />\n        ) /* use a ternary and render null if isLoading is false */\n      }\n    </div>\n  );\n};\n\n/**\n * Boostrap the <App /> component into the '#app' element in the DOM,\n * using ReactDOM.render();\n */\nReactDOM.render(<App />, document.getElementById(\"app\"));\n"],"sourceRoot":""}